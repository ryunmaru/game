<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mini FPS</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: crisp-edges;
      cursor: crosshair;
    }
    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 16px;
      color: #fff;
      text-shadow: 0 0 6px #000;
      font-weight: 600;
    }
    #message {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      text-align: center;
      line-height: 1.8;
      background: rgba(0, 0, 0, 0.5);
      padding: 16px 22px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 12px;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="game" width="960" height="540"></canvas>
  <div id="hud">
    <div id="stats">HP: 100 | Score: 0 | Ammo: 8/8</div>
    <div>WASD:移動 / マウス:視点 / クリック:射撃</div>
  </div>
  <div id="message">クリックして開始<br/>敵を倒してスコアを伸ばそう</div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statsEl = document.getElementById("stats");
    const messageEl = document.getElementById("message");

    const FOV = Math.PI / 3;
    const MAP = [
      "################",
      "#.......#......#",
      "#.###...#..##..#",
      "#.#.....#......#",
      "#.#.###.#.###..#",
      "#.#...#.#...#..#",
      "#...#.#...#....#",
      "###.#.#####.##.#",
      "#...#.......#..#",
      "#..#####.##.#..#",
      "#......#....#..#",
      "#.##.#.#.##.#..#",
      "#....#.#....#..#",
      "#..#...#..#....#",
      "#......#.......#",
      "################",
    ];

    const player = {
      x: 2.5,
      y: 2.5,
      angle: 0,
      speed: 2.8,
      turnSpeed: 2.4,
      hp: 100,
      ammo: 8,
      maxAmmo: 8,
      score: 0,
      shootCooldown: 0,
      reloadTimer: 0,
    };

    const keys = {};
    const enemies = [];
    const particles = [];
    let spawnTimer = 0;
    let lastTime = 0;
    let isGameOver = false;

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function inWall(x, y) {
      const xi = Math.floor(x);
      const yi = Math.floor(y);
      if (yi < 0 || yi >= MAP.length || xi < 0 || xi >= MAP[0].length) return true;
      return MAP[yi][xi] === "#";
    }

    function spawnEnemy() {
      for (let i = 0; i < 30; i++) {
        const x = rand(1.5, MAP[0].length - 1.5);
        const y = rand(1.5, MAP.length - 1.5);
        if (inWall(x, y)) continue;
        const dx = x - player.x;
        const dy = y - player.y;
        if (Math.hypot(dx, dy) < 4) continue;
        enemies.push({
          x,
          y,
          hp: 2,
          speed: rand(0.65, 1.1),
          attackCooldown: 0,
        });
        return;
      }
    }

    function castRay(angle) {
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);
      let dist = 0;
      while (dist < 20) {
        dist += 0.02;
        const x = player.x + cos * dist;
        const y = player.y + sin * dist;
        if (inWall(x, y)) {
          return { dist, x, y };
        }
      }
      return { dist: 20, x: player.x + cos * 20, y: player.y + sin * 20 };
    }

    function normalizeAngle(a) {
      while (a > Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    function movePlayer(dt) {
      let moveX = 0;
      let moveY = 0;
      const forward = (keys["KeyW"] ? 1 : 0) - (keys["KeyS"] ? 1 : 0);
      const strafe = (keys["KeyD"] ? 1 : 0) - (keys["KeyA"] ? 1 : 0);

      moveX += Math.cos(player.angle) * forward;
      moveY += Math.sin(player.angle) * forward;
      moveX += Math.cos(player.angle + Math.PI / 2) * strafe;
      moveY += Math.sin(player.angle + Math.PI / 2) * strafe;

      const length = Math.hypot(moveX, moveY) || 1;
      moveX /= length;
      moveY /= length;

      const step = player.speed * dt;
      const nx = player.x + moveX * step;
      const ny = player.y + moveY * step;

      if (!inWall(nx, player.y)) player.x = nx;
      if (!inWall(player.x, ny)) player.y = ny;

      const turn = (keys["ArrowRight"] ? 1 : 0) - (keys["ArrowLeft"] ? 1 : 0);
      player.angle += turn * player.turnSpeed * dt;
    }

    function updateEnemies(dt) {
      enemies.forEach((enemy) => {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);
        enemy.attackCooldown -= dt;

        if (dist > 0.7) {
          const nx = enemy.x + (dx / dist) * enemy.speed * dt;
          const ny = enemy.y + (dy / dist) * enemy.speed * dt;
          if (!inWall(nx, enemy.y)) enemy.x = nx;
          if (!inWall(enemy.x, ny)) enemy.y = ny;
        } else if (enemy.attackCooldown <= 0) {
          player.hp -= 8;
          enemy.attackCooldown = 0.8;
          particles.push({ life: 0.2, color: "#f33" });
        }
      });

      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].hp <= 0) {
          enemies.splice(i, 1);
          player.score += 100;
        }
      }
    }

    function shoot() {
      if (isGameOver || player.reloadTimer > 0 || player.shootCooldown > 0) return;
      if (player.ammo <= 0) {
        player.reloadTimer = 1.2;
        return;
      }

      player.ammo -= 1;
      player.shootCooldown = 0.2;
      particles.push({ life: 0.08, color: "#ffda6b" });

      let bestTarget = null;
      let bestDist = Infinity;
      enemies.forEach((enemy) => {
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        const angleToEnemy = Math.atan2(dy, dx);
        const delta = Math.abs(normalizeAngle(angleToEnemy - player.angle));
        if (delta < 0.09 && dist < bestDist) {
          bestDist = dist;
          bestTarget = enemy;
        }
      });

      if (bestTarget) {
        const wall = castRay(Math.atan2(bestTarget.y - player.y, bestTarget.x - player.x));
        if (wall.dist + 0.05 > bestDist) {
          bestTarget.hp -= 1;
        }
      }

      if (player.ammo === 0) {
        player.reloadTimer = 1.2;
      }
    }

    function renderSkyAndFloor() {
      const h = canvas.height;
      const w = canvas.width;
      ctx.fillStyle = "#4d7bb4";
      ctx.fillRect(0, 0, w, h / 2);
      const floorGrad = ctx.createLinearGradient(0, h / 2, 0, h);
      floorGrad.addColorStop(0, "#3a3a3a");
      floorGrad.addColorStop(1, "#191919");
      ctx.fillStyle = floorGrad;
      ctx.fillRect(0, h / 2, w, h / 2);
    }

    function renderWorld() {
      renderSkyAndFloor();
      const rays = canvas.width;
      const zBuffer = new Array(rays);

      for (let x = 0; x < rays; x++) {
        const cameraX = (x / rays) * 2 - 1;
        const rayAngle = player.angle + cameraX * (FOV / 2);
        const hit = castRay(rayAngle);
        const correctedDist = hit.dist * Math.cos(rayAngle - player.angle);
        zBuffer[x] = correctedDist;

        const wallHeight = Math.min(canvas.height, (canvas.height * 0.9) / correctedDist);
        const shade = Math.max(20, 220 - correctedDist * 26);
        ctx.fillStyle = `rgb(${shade}, ${shade * 0.92}, ${shade * 0.8})`;
        ctx.fillRect(x, (canvas.height - wallHeight) / 2, 1, wallHeight);
      }

      const sprites = enemies
        .map((enemy) => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.hypot(dx, dy);
          const angle = normalizeAngle(Math.atan2(dy, dx) - player.angle);
          return { enemy, dist, angle };
        })
        .filter((s) => Math.abs(s.angle) < FOV / 1.4)
        .sort((a, b) => b.dist - a.dist);

      sprites.forEach(({ enemy, dist, angle }) => {
        const size = Math.min(canvas.height * 0.8, (canvas.height * 0.8) / dist);
        const sx = (angle / (FOV / 2)) * (canvas.width / 2) + canvas.width / 2;
        const left = Math.floor(sx - size / 2);
        const right = Math.floor(sx + size / 2);

        for (let x = left; x < right; x++) {
          if (x < 0 || x >= canvas.width) continue;
          if (zBuffer[x] < dist) continue;
          const healthRatio = Math.max(0, enemy.hp / 2);
          ctx.fillStyle = `rgb(${230}, ${Math.floor(70 + healthRatio * 80)}, ${Math.floor(70 + healthRatio * 80)})`;
          ctx.fillRect(x, canvas.height / 2 - size / 2, 1, size);
        }
      });

      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 - 8, canvas.height / 2);
      ctx.lineTo(canvas.width / 2 + 8, canvas.height / 2);
      ctx.moveTo(canvas.width / 2, canvas.height / 2 - 8);
      ctx.lineTo(canvas.width / 2, canvas.height / 2 + 8);
      ctx.stroke();
    }

    function update(dt) {
      if (isGameOver) return;

      movePlayer(dt);
      updateEnemies(dt);

      player.shootCooldown = Math.max(0, player.shootCooldown - dt);
      player.reloadTimer = Math.max(0, player.reloadTimer - dt);
      if (player.reloadTimer === 0 && player.ammo === 0) {
        player.ammo = player.maxAmmo;
      }

      spawnTimer -= dt;
      if (spawnTimer <= 0 && enemies.length < 9) {
        spawnEnemy();
        spawnTimer = rand(0.9, 1.4);
      }

      particles.forEach((p) => (p.life -= dt));
      for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].life <= 0) particles.splice(i, 1);
      }

      if (player.hp <= 0) {
        isGameOver = true;
        messageEl.classList.remove("hidden");
        messageEl.innerHTML = `ゲームオーバー<br/>Score: ${player.score}<br/>Rキーでリスタート`;
      }

      statsEl.textContent = `HP: ${Math.max(0, Math.floor(player.hp))} | Score: ${player.score} | Ammo: ${player.ammo}/${player.maxAmmo}${player.reloadTimer > 0 ? " (Reload...)" : ""}`;
    }

    function renderEffects() {
      particles.forEach((p) => {
        ctx.globalAlpha = Math.min(1, p.life * 10);
        ctx.fillStyle = p.color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
      });
    }

    function frame(timestamp) {
      const dt = Math.min(0.033, (timestamp - lastTime) / 1000 || 0);
      lastTime = timestamp;

      update(dt);
      renderWorld();
      renderEffects();

      requestAnimationFrame(frame);
    }

    function resetGame() {
      player.x = 2.5;
      player.y = 2.5;
      player.angle = 0;
      player.hp = 100;
      player.score = 0;
      player.ammo = player.maxAmmo;
      player.shootCooldown = 0;
      player.reloadTimer = 0;
      enemies.length = 0;
      particles.length = 0;
      isGameOver = false;
      spawnTimer = 0;
      messageEl.classList.add("hidden");
    }

    window.addEventListener("keydown", (e) => {
      keys[e.code] = true;
      if (e.code === "KeyR" && isGameOver) {
        resetGame();
      }
    });
    window.addEventListener("keyup", (e) => (keys[e.code] = false));

    canvas.addEventListener("click", async () => {
      if (document.pointerLockElement !== canvas) {
        await canvas.requestPointerLock();
        messageEl.classList.add("hidden");
      } else {
        shoot();
      }
    });

    document.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement === canvas && !isGameOver) {
        player.angle += e.movementX * 0.0024;
      }
    });

    requestAnimationFrame(frame);
  </script>
</body>
</html>
