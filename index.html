<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Mini FPS 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: system-ui, sans-serif; touch-action: none; }
    #hud { position: fixed; inset: 0; pointer-events: none; color: #fff; text-shadow: 0 0 8px #000; padding: 12px; display:flex; justify-content:space-between; font-weight:700; }
    #center { position: fixed; left:50%; top:50%; transform:translate(-50%,-50%); color:#fff; font-size:24px; opacity:.9; pointer-events:none; }
    #message { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); color:#fff; background:rgba(0,0,0,.55); border:1px solid #ffffff55; border-radius:12px; padding:16px 20px; text-align:center; }
    .hidden { display:none; }
    #mobile { position: fixed; inset:0; pointer-events:none; }
    .stick { position:fixed; bottom:max(16px, env(safe-area-inset-bottom)); width:130px; height:130px; border-radius:50%; background:#ffffff1f; border:1px solid #ffffff44; pointer-events:auto; }
    .stick.left { left:14px; } .stick.right { right:14px; }
    .nub { position:absolute; left:50%; top:50%; width:52px; height:52px; border-radius:50%; transform:translate(-50%,-50%); background:#ffffff6b; }
    #fire { position:fixed; right:160px; bottom:max(26px, env(safe-area-inset-bottom)); width:82px; height:82px; border-radius:50%; border:1px solid #fff9; background:#ff4d4db0; color:#fff; font-weight:800; pointer-events:auto; }
    @media (hover:hover) and (pointer:fine) { #mobile { display:none; } }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="hud"><div id="stats">HP: 100 | Score: 0 | Ammo: 12/12</div><div id="help">WASD 移動 / マウス視点 / クリック射撃</div></div>
  <div id="center">+</div>
  <div id="message">クリック / タップで開始<br>3D FPS版</div>
  <div id="mobile">
    <div id="move" class="stick left"><div class="nub"></div></div>
    <button id="fire">FIRE</button>
    <div id="look" class="stick right"><div class="nub"></div></div>
  </div>

  <script type="module">
    import * as THREE from 'three';

    const MAP = [
      '################', '#..............#', '#.###.####.###.#', '#...#....#.....#', '#.#.#.##.#.###.#', '#.#....#.#...#.#', '#.####.#.###.#.#', '#......#.....#.#', '#.####.#####.#.#', '#.#..........#.#', '#.#.##########.#', '#.#............#', '#.######.#######', '#..............#', '################'
    ];

    const statsEl = document.getElementById('stats');
    const helpEl = document.getElementById('help');
    const messageEl = document.getElementById('message');
    const centerEl = document.getElementById('center');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87b7ff);
    scene.fog = new THREE.Fog(0x87b7ff, 10, 35);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.7); dir.position.set(5,10,2); scene.add(dir);

    const world = new THREE.Group(); scene.add(world);
    const wallMeshes = [];

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({ color: 0x4a4a4a }));
    floor.rotation.x = -Math.PI / 2; floor.position.set(7, 0, 7); world.add(floor);

    const ceil = new THREE.Mesh(new THREE.PlaneGeometry(40,40), new THREE.MeshStandardMaterial({ color: 0xd8ecff, side: THREE.BackSide }));
    ceil.rotation.x = Math.PI/2; ceil.position.set(7, 4.2, 7); world.add(ceil);

    for (let z=0; z<MAP.length; z++) for (let x=0; x<MAP[0].length; x++) if (MAP[z][x] === '#') {
      const m = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 1), new THREE.MeshStandardMaterial({ color: 0xa37a57 }));
      m.position.set(x, 2, z); world.add(m); wallMeshes.push(m);
    }

    function isWall(x,z){ const xi=Math.floor(x+0.5), zi=Math.floor(z+0.5); return zi<0||zi>=MAP.length||xi<0||xi>=MAP[0].length||MAP[zi][xi]==='#'; }
    function findStart(){ for(let z=0; z<MAP.length; z++) for(let x=0; x<MAP[0].length; x++) if(MAP[z][x]==='.') return {x,z}; return {x:1,z:1}; }

    const start = findStart();
    const player = { pos:new THREE.Vector3(start.x,1.7,start.z), yaw:0, hp:100, ammo:12, maxAmmo:12, score:0, shotCd:0, reload:0 };
    camera.position.copy(player.pos);

    const enemies = [];
    const enemyGeom = new THREE.CapsuleGeometry(0.3, 1.0, 4, 8);
    function spawnEnemy(){
      for(let i=0;i<20;i++){
        const x=1+Math.random()*(MAP[0].length-2), z=1+Math.random()*(MAP.length-2);
        if(isWall(x,z) || Math.hypot(x-player.pos.x,z-player.pos.z)<5) continue;
        const mesh = new THREE.Mesh(enemyGeom, new THREE.MeshStandardMaterial({ color: 0xcc4444 }));
        mesh.position.set(x,1.0,z); scene.add(mesh);
        enemies.push({ mesh, hp:5, state:'patrol', target:new THREE.Vector3(x,1,z), cd:Math.random(), hitFlash:0, speed:1+Math.random()*0.5 });
        return;
      }
    }

    for(let i=0;i<4;i++) spawnEnemy();

    const keys={}; let started=false; let over=false;
    const touch={move:new THREE.Vector2(), look:new THREE.Vector2(), fire:false};

    function tryMove(v){ if(!isWall(v.x, player.pos.z)) player.pos.x=v.x; if(!isWall(player.pos.x, v.z)) player.pos.z=v.z; }

    function hasLOS(a,b){
      const dir = new THREE.Vector3().subVectors(b,a); const dist=dir.length(); dir.normalize();
      const ray = new THREE.Raycaster(a, dir, 0, dist);
      return ray.intersectObjects(wallMeshes,false).length===0;
    }

    function enemyAI(e, dt){
      const p = player.pos; const d = p.distanceTo(e.mesh.position); const canSee = d<11 && hasLOS(e.mesh.position,p);
      e.cd -= dt; e.hitFlash = Math.max(0,e.hitFlash-dt*4);
      if(canSee) e.state = d>2.4 ? 'chase' : 'combat';
      else if(e.state!=='patrol' && d>4) e.state='patrol';

      if(e.state==='chase'){
        const dir = new THREE.Vector3().subVectors(p,e.mesh.position).setY(0).normalize();
        const nx = e.mesh.position.x + dir.x*e.speed*dt; const nz = e.mesh.position.z + dir.z*e.speed*dt;
        if(!isWall(nx,nz)) e.mesh.position.set(nx,1,nz);
      } else if(e.state==='combat'){
        const toP = new THREE.Vector3().subVectors(p,e.mesh.position).setY(0).normalize();
        const side = new THREE.Vector3(-toP.z,0,toP.x).multiplyScalar((Math.random()<0.5?-1:1)*e.speed*0.45*dt);
        const nx=e.mesh.position.x+side.x, nz=e.mesh.position.z+side.z; if(!isWall(nx,nz)) e.mesh.position.set(nx,1,nz);
        if(e.cd<=0){ if(Math.random()<0.45){ player.hp-=6; } e.cd=0.8+Math.random()*0.7; }
      } else {
        if(e.mesh.position.distanceTo(e.target)<0.3 || Math.random()<0.01){
          e.target.set(1+Math.random()*(MAP[0].length-2),1,1+Math.random()*(MAP.length-2));
          if(isWall(e.target.x,e.target.z)) e.target.copy(e.mesh.position);
        }
        const dir = new THREE.Vector3().subVectors(e.target,e.mesh.position).setY(0); const len=dir.length();
        if(len>0.01){ dir.normalize(); const nx=e.mesh.position.x+dir.x*e.speed*0.45*dt; const nz=e.mesh.position.z+dir.z*e.speed*0.45*dt; if(!isWall(nx,nz)) e.mesh.position.set(nx,1,nz); }
      }
      e.mesh.lookAt(player.pos.x,1,player.pos.z);
      e.mesh.material.color.setRGB(0.8+0.2*e.hitFlash,0.2+0.8*e.hitFlash,0.2+0.4*e.hitFlash);
    }

    function shoot(){
      if(!started||over||player.shotCd>0||player.reload>0) return;
      if(player.ammo<=0){ player.reload=1.1; return; }
      player.ammo--; player.shotCd=0.16;
      const dir = new THREE.Vector3(Math.sin(player.yaw),0,Math.cos(player.yaw));
      const ray = new THREE.Raycaster(player.pos, dir, 0, 18);
      const hits = ray.intersectObjects(enemies.map(e=>e.mesh), false);
      const wallHit = ray.intersectObjects(wallMeshes,false)[0];
      if(hits[0] && (!wallHit || hits[0].distance < wallHit.distance)){
        const hitEnemy = enemies.find(e=>e.mesh===hits[0].object);
        if(hitEnemy){ hitEnemy.hp--; hitEnemy.hitFlash=1; centerEl.textContent='✕'; setTimeout(()=>centerEl.textContent='+',80); }
      }
      if(player.ammo===0) player.reload=1.1;
    }

    function update(dt){
      if(!started||over) return;
      const f=((keys.KeyW?1:0)-(keys.KeyS?1:0)) + (-touch.move.y);
      const s=((keys.KeyD?1:0)-(keys.KeyA?1:0)) + touch.move.x;
      const vel = new THREE.Vector3(Math.sin(player.yaw)*f + Math.sin(player.yaw+Math.PI/2)*s,0,Math.cos(player.yaw)*f + Math.cos(player.yaw+Math.PI/2)*s);
      if(vel.lengthSq()>0) vel.normalize().multiplyScalar(3.2*dt);
      tryMove(new THREE.Vector3(player.pos.x+vel.x,0,player.pos.z+vel.z));
      player.yaw += (((keys.ArrowRight?1:0)-(keys.ArrowLeft?1:0))*2.3 + touch.look.x*2.1) * dt;

      player.shotCd=Math.max(0,player.shotCd-dt); player.reload=Math.max(0,player.reload-dt); if(player.reload===0&&player.ammo===0) player.ammo=player.maxAmmo;
      enemies.forEach(e=>enemyAI(e,dt));
      for(let i=enemies.length-1;i>=0;i--) if(enemies[i].hp<=0){ scene.remove(enemies[i].mesh); enemies.splice(i,1); player.score+=150; }
      if(enemies.length<7 && Math.random()<dt*0.75) spawnEnemy();
      if(touch.fire) shoot();

      if(player.hp<=0){ over=true; messageEl.classList.remove('hidden'); messageEl.innerHTML=`ゲームオーバー<br>Score: ${player.score}<br>Rキー / タップで再開`; }

      camera.position.copy(player.pos);
      camera.rotation.set(0, player.yaw, 0);
      statsEl.textContent=`HP: ${Math.max(0,Math.floor(player.hp))} | Score: ${player.score} | Ammo: ${player.ammo}/${player.maxAmmo} ${player.reload>0?'(Reload...)':''} | Enemies: ${enemies.length}`;
    }

    function loop(t){ const dt=Math.min(0.033, (t-(loop.t||t))/1000); loop.t=t; update(dt); renderer.render(scene,camera); requestAnimationFrame(loop); }

    function start(){ started=true; messageEl.classList.add('hidden'); }
    function reset(){ player.pos.set(start.x,1.7,start.z); player.hp=100; player.score=0; player.ammo=player.maxAmmo; over=false; started=true; messageEl.classList.add('hidden'); enemies.splice(0).forEach(e=>scene.remove(e.mesh)); for(let i=0;i<4;i++) spawnEnemy(); }

    addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
    addEventListener('keydown',e=>{ keys[e.code]=true; if(['KeyW','KeyA','KeyS','KeyD','ArrowLeft','ArrowRight'].includes(e.code)) start(); if(e.code==='KeyR'&&over) reset(); });
    addEventListener('keyup',e=>keys[e.code]=false);
    document.addEventListener('mousemove',e=>{ if(document.pointerLockElement===renderer.domElement && !over){ player.yaw += e.movementX*0.0024; }});

    renderer.domElement.addEventListener('click', async ()=>{
      start();
      if(over){ reset(); return; }
      const desktop = matchMedia('(hover:hover) and (pointer:fine)').matches;
      if(desktop){ if(document.pointerLockElement!==renderer.domElement){ try{ await renderer.domElement.requestPointerLock(); }catch{} } else shoot(); }
      else shoot();
    });

    function setupStick(id, out, dead=0.08){
      const el=document.getElementById(id), nub=el.querySelector('.nub'); let pid=null;
      const set=(x,y)=>{ const r=el.getBoundingClientRect(), cx=r.left+r.width/2, cy=r.top+r.height/2, max=r.width*0.34; let dx=(x-cx)/max, dy=(y-cy)/max; const m=Math.hypot(dx,dy); if(m>1){dx/=m;dy/=m;} if(Math.abs(dx)<dead)dx=0; if(Math.abs(dy)<dead)dy=0; out.set(dx,dy); nub.style.transform=`translate(calc(-50% + ${dx*max}px), calc(-50% + ${dy*max}px))`; };
      el.addEventListener('pointerdown',e=>{pid=e.pointerId; el.setPointerCapture(pid); start(); set(e.clientX,e.clientY);});
      el.addEventListener('pointermove',e=>{if(e.pointerId===pid) set(e.clientX,e.clientY);});
      const end=e=>{if(e.pointerId!==pid)return; pid=null; out.set(0,0); nub.style.transform='translate(-50%,-50%)';};
      el.addEventListener('pointerup',end); el.addEventListener('pointercancel',end);
    }
    setupStick('move', touch.move); setupStick('look', touch.look, 0.05);
    const fire=document.getElementById('fire');
    fire.addEventListener('pointerdown',e=>{ start(); touch.fire=true; fire.setPointerCapture(e.pointerId); });
    fire.addEventListener('pointerup',()=>touch.fire=false); fire.addEventListener('pointercancel',()=>touch.fire=false);

    if(!matchMedia('(hover:hover) and (pointer:fine)').matches) helpEl.textContent='左スティック移動 / 右スティック視点 / FIRE射撃';

    requestAnimationFrame(loop);
  </script>
</body>
</html>
